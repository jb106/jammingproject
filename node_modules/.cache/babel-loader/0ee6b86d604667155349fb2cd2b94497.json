{"ast":null,"code":"// TODO the clientId should not be committed to a public repo, so remove it and load it from a file?\nvar clientId = \"xxx\";\nvar spotifySearchAPI = 'https://api.spotify.com/v1/search';\nvar spotifyUserProfileAPI = 'https://api.spotify.com/v1/me'; // @Reviewer: what's the preferred way to store urls with dynamic content?\n\nvar spotifyPlaylistAPI = 'https://api.spotify.com/v1/users/${userId}/playlists';\nvar spotifyPlaylistTracksAPI = 'https://api.spotify.com/v1/users/${userId}/playlists/${playlistId}/tracks';\nvar spotifyRedirectUrl = \"http://localhost:3000\";\nvar accessToken;\nvar expiresIn;\nvar Spotify = {\n  getAccessToken: function getAccessToken() {\n    // 1. case: already there?\n    if (accessToken) {\n      return accessToken;\n    } // 2. case: already in URL?\n\n\n    var url = window.location.href;\n    accessToken = this.extract(url, \"access_token=\", \"&\");\n\n    if (accessToken) {\n      expiresIn = this.extract(url, \"expires_in=\", \"&\");\n      window.setTimeout(function () {\n        return accessToken = '';\n      }, expiresIn * 1000);\n      window.history.pushState('Access Token', null, '/');\n      console.log(\"access token successful retrieved.\");\n      return accessToken;\n    } else {\n      // 3. case: fetch from spotify\n      var state = 4321; // TODO generate state, save to app-state and validate\n\n      window.location.href = \"https://accounts.spotify.com/authorize?client_id=\".concat(clientId, \"&response_type=token&scope=playlist-modify-private&redirect_uri=\").concat(spotifyRedirectUrl, \"&state=\").concat(state);\n    }\n  },\n\n  /* returns a promise */\n  search: function search(term) {\n    return fetch(\"\".concat(spotifySearchAPI, \"?type=track&q=\").concat(term), {\n      headers: this.buildAuthorizationHeader()\n    }).then(function (response) {\n      return response.json();\n    }).then(function (jsonResponse) {\n      if (jsonResponse.tracks) {\n        return jsonResponse.tracks.items.map(function (track) {\n          return {\n            id: track.id,\n            name: track.name,\n            uri: track.uri,\n            album: track.album.name,\n            artist: track.artists[0].name\n          };\n        });\n      } else {\n        return [];\n      }\n    });\n  },\n\n  /* returns a promise */\n  savePlaylist: function savePlaylist(name, trackURIs) {\n    var _this = this;\n\n    return fetch(\"\".concat(spotifyUserProfileAPI), {\n      headers: this.buildAuthorizationHeader()\n    }).then(function (response) {\n      return response.json();\n    }).then(function (jsonResponse) {\n      var userId = jsonResponse.id;\n      return _this.createPlaylistWithTracks(userId, name, trackURIs);\n    });\n  },\n\n  /* returns a promise */\n  createPlaylistWithTracks: function createPlaylistWithTracks(userId, playlistName, playlistTracks) {\n    var _this2 = this;\n\n    var jsonBody = JSON.stringify({\n      name: playlistName,\n      public: false\n    });\n    var url = spotifyPlaylistAPI.replace(\"${userId}\", userId);\n    return fetch(url, {\n      headers: this.buildAuthorizationHeader(),\n      method: 'POST',\n      body: jsonBody\n    }).then(function (response) {\n      return _this2.handleResponse(response);\n    }).then(function (jsonResponse) {\n      console.log(\"playlist successful created.\");\n      var playlistId = jsonResponse.id;\n      return _this2.saveTracksToPlaylist(userId, playlistId, playlistTracks);\n    });\n  },\n\n  /* returns a promise */\n  saveTracksToPlaylist: function saveTracksToPlaylist(userId, playlistId, playlistTracks) {\n    var _this3 = this;\n\n    var jsonBody = JSON.stringify(playlistTracks);\n    var url = spotifyPlaylistTracksAPI.replace(\"${userId}\", userId).replace(\"${playlistId}\", playlistId);\n    return fetch(url, {\n      headers: this.buildAuthorizationHeader(),\n      method: 'POST',\n      body: jsonBody\n    }).then(function (response) {\n      return _this3.handleResponse(response);\n    }).then(function (jsonResponse) {\n      console.log(\"tracks successful stored\");\n      return jsonResponse.snapshot_id;\n    });\n  },\n\n  /* returns a promise */\n  handleResponse: function handleResponse(response) {\n    if (response.ok) {\n      return response.json();\n    }\n\n    throw new Error('Request failed!');\n  },\n  buildAuthorizationHeader: function buildAuthorizationHeader() {\n    var token = this.getAccessToken();\n    return {\n      Authorization: \"Bearer \".concat(token)\n    };\n  },\n\n  /* extracts everything between the end of the keyword and the limiter from the string. if the keyword\n   * was not found, return undefined. */\n  // TODO write some tests for this\n  extract: function extract(string, keyword, limiter) {\n    var startIndex = string.indexOf(keyword);\n\n    if (startIndex !== -1) {\n      // add the length of the keyword to the start position to get the \"real\" start\n      startIndex += keyword.length;\n      var endIndex = string.indexOf(limiter, startIndex);\n\n      if (endIndex !== -1) {\n        return string.slice(startIndex, endIndex);\n      } else {\n        return string.slice(startIndex);\n      }\n    }\n\n    return undefined;\n  }\n};\nexport default Spotify;","map":{"version":3,"sources":["/Users/jbl/Desktop/jamming-master/src/util/Spotify.js"],"names":["clientId","spotifySearchAPI","spotifyUserProfileAPI","spotifyPlaylistAPI","spotifyPlaylistTracksAPI","spotifyRedirectUrl","accessToken","expiresIn","Spotify","getAccessToken","url","window","location","href","extract","setTimeout","history","pushState","console","log","state","search","term","fetch","headers","buildAuthorizationHeader","then","response","json","jsonResponse","tracks","items","map","track","id","name","uri","album","artist","artists","savePlaylist","trackURIs","userId","createPlaylistWithTracks","playlistName","playlistTracks","jsonBody","JSON","stringify","public","replace","method","body","handleResponse","playlistId","saveTracksToPlaylist","snapshot_id","ok","Error","token","Authorization","string","keyword","limiter","startIndex","indexOf","length","endIndex","slice","undefined"],"mappings":"AAAA;AACA,IAAMA,QAAQ,GAAG,KAAjB;AACA,IAAMC,gBAAgB,GAAG,mCAAzB;AACA,IAAMC,qBAAqB,GAAG,+BAA9B,C,CACA;;AACA,IAAMC,kBAAkB,GAAG,sDAA3B;AACA,IAAMC,wBAAwB,GAAG,2EAAjC;AACA,IAAMC,kBAAkB,GAAG,uBAA3B;AAEA,IAAIC,WAAJ;AACA,IAAIC,SAAJ;AAEA,IAAMC,OAAO,GAAG;AAEZC,EAAAA,cAFY,4BAEK;AACb;AACA,QAAIH,WAAJ,EAAiB;AACb,aAAOA,WAAP;AACH,KAJY,CAKb;;;AACA,QAAII,GAAG,GAAGC,MAAM,CAACC,QAAP,CAAgBC,IAA1B;AACAP,IAAAA,WAAW,GAAG,KAAKQ,OAAL,CAAaJ,GAAb,EAAkB,eAAlB,EAAmC,GAAnC,CAAd;;AACA,QAAIJ,WAAJ,EAAiB;AACbC,MAAAA,SAAS,GAAG,KAAKO,OAAL,CAAaJ,GAAb,EAAkB,aAAlB,EAAiC,GAAjC,CAAZ;AACAC,MAAAA,MAAM,CAACI,UAAP,CAAkB;AAAA,eAAMT,WAAW,GAAG,EAApB;AAAA,OAAlB,EAA0CC,SAAS,GAAG,IAAtD;AACAI,MAAAA,MAAM,CAACK,OAAP,CAAeC,SAAf,CAAyB,cAAzB,EAAyC,IAAzC,EAA+C,GAA/C;AACAC,MAAAA,OAAO,CAACC,GAAR,CAAY,oCAAZ;AACA,aAAOb,WAAP;AACH,KAND,MAMO;AACH;AACA,UAAIc,KAAK,GAAG,IAAZ,CAFG,CAEe;;AAClBT,MAAAA,MAAM,CAACC,QAAP,CAAgBC,IAAhB,8DAA2Eb,QAA3E,6EAAsJK,kBAAtJ,oBAAkLe,KAAlL;AACH;AACJ,GArBW;;AAuBZ;AACAC,EAAAA,MAxBY,kBAwBLC,IAxBK,EAwBC;AACT,WAAOC,KAAK,WAAItB,gBAAJ,2BAAqCqB,IAArC,GACR;AAACE,MAAAA,OAAO,EAAE,KAAKC,wBAAL;AAAV,KADQ,CAAL,CAEFC,IAFE,CAEG,UAAAC,QAAQ;AAAA,aAAIA,QAAQ,CAACC,IAAT,EAAJ;AAAA,KAFX,EAGFF,IAHE,CAGG,UAAAG,YAAY,EAAI;AAClB,UAAIA,YAAY,CAACC,MAAjB,EAAyB;AACrB,eAAOD,YAAY,CAACC,MAAb,CAAoBC,KAApB,CAA0BC,GAA1B,CAA8B,UAASC,KAAT,EAAgB;AACjD,iBAAO;AACHC,YAAAA,EAAE,EAAED,KAAK,CAACC,EADP;AAEHC,YAAAA,IAAI,EAAEF,KAAK,CAACE,IAFT;AAGHC,YAAAA,GAAG,EAAEH,KAAK,CAACG,GAHR;AAIHC,YAAAA,KAAK,EAAEJ,KAAK,CAACI,KAAN,CAAYF,IAJhB;AAKHG,YAAAA,MAAM,EAAEL,KAAK,CAACM,OAAN,CAAc,CAAd,EAAiBJ;AALtB,WAAP;AAME,SAPC,CAAP;AAQE,OATN,MAUK;AACD,eAAO,EAAP;AACH;AACJ,KAjBE,CAAP;AAkBH,GA3CW;;AA6CZ;AACAK,EAAAA,YA9CY,wBA8CCL,IA9CD,EA8COM,SA9CP,EA8CkB;AAAA;;AAC5B,WAAOlB,KAAK,WAAIrB,qBAAJ,GACR;AAACsB,MAAAA,OAAO,EAAE,KAAKC,wBAAL;AAAV,KADQ,CAAL,CAEFC,IAFE,CAEG,UAAAC,QAAQ;AAAA,aAAIA,QAAQ,CAACC,IAAT,EAAJ;AAAA,KAFX,EAGFF,IAHE,CAGG,UAAAG,YAAY,EAAI;AAClB,UAAIa,MAAM,GAAGb,YAAY,CAACK,EAA1B;AACA,aAAO,KAAI,CAACS,wBAAL,CAA8BD,MAA9B,EAAsCP,IAAtC,EAA4CM,SAA5C,CAAP;AACH,KANE,CAAP;AAOD,GAtDW;;AAwDZ;AACAE,EAAAA,wBAzDY,oCAyDaD,MAzDb,EAyDqBE,YAzDrB,EAyDmCC,cAzDnC,EAyDmD;AAAA;;AAC3D,QAAIC,QAAQ,GAAGC,IAAI,CAACC,SAAL,CAAe;AAACb,MAAAA,IAAI,EAAES,YAAP;AAAqBK,MAAAA,MAAM,EAAE;AAA7B,KAAf,CAAf;AACA,QAAIvC,GAAG,GAAGP,kBAAkB,CAAC+C,OAAnB,CAA2B,WAA3B,EAAwCR,MAAxC,CAAV;AACA,WAAOnB,KAAK,CAACb,GAAD,EAAM;AAAEc,MAAAA,OAAO,EAAE,KAAKC,wBAAL,EAAX;AACd0B,MAAAA,MAAM,EAAC,MADO;AACCC,MAAAA,IAAI,EAAEN;AADP,KAAN,CAAL,CAEFpB,IAFE,CAEG,UAAAC,QAAQ;AAAA,aAAI,MAAI,CAAC0B,cAAL,CAAoB1B,QAApB,CAAJ;AAAA,KAFX,EAGFD,IAHE,CAGG,UAAAG,YAAY,EAAI;AAClBX,MAAAA,OAAO,CAACC,GAAR,CAAY,8BAAZ;AACA,UAAImC,UAAU,GAAGzB,YAAY,CAACK,EAA9B;AACA,aAAO,MAAI,CAACqB,oBAAL,CAA0Bb,MAA1B,EAAkCY,UAAlC,EAA8CT,cAA9C,CAAP;AACH,KAPE,CAAP;AAQH,GApEW;;AAsEZ;AACAU,EAAAA,oBAvEY,gCAuESb,MAvET,EAuEiBY,UAvEjB,EAuE6BT,cAvE7B,EAuE6C;AAAA;;AACrD,QAAIC,QAAQ,GAAGC,IAAI,CAACC,SAAL,CAAeH,cAAf,CAAf;AACA,QAAInC,GAAG,GAAGN,wBAAwB,CAAC8C,OAAzB,CAAiC,WAAjC,EAA8CR,MAA9C,EAAsDQ,OAAtD,CAA8D,eAA9D,EAA+EI,UAA/E,CAAV;AACA,WAAO/B,KAAK,CAACb,GAAD,EAAM;AAAEc,MAAAA,OAAO,EAAE,KAAKC,wBAAL,EAAX;AACd0B,MAAAA,MAAM,EAAC,MADO;AACCC,MAAAA,IAAI,EAAEN;AADP,KAAN,CAAL,CAEFpB,IAFE,CAEG,UAAAC,QAAQ;AAAA,aAAI,MAAI,CAAC0B,cAAL,CAAoB1B,QAApB,CAAJ;AAAA,KAFX,EAGFD,IAHE,CAGG,UAAAG,YAAY,EAAI;AAClBX,MAAAA,OAAO,CAACC,GAAR,CAAY,0BAAZ;AACA,aAAOU,YAAY,CAAC2B,WAApB;AACH,KANE,CAAP;AAOH,GAjFW;;AAmFZ;AACAH,EAAAA,cApFY,0BAoFG1B,QApFH,EAoFa;AACrB,QAAIA,QAAQ,CAAC8B,EAAb,EAAiB;AACb,aAAO9B,QAAQ,CAACC,IAAT,EAAP;AACH;;AACD,UAAM,IAAI8B,KAAJ,CAAU,iBAAV,CAAN;AACH,GAzFW;AA2FZjC,EAAAA,wBA3FY,sCA2Fe;AACvB,QAAIkC,KAAK,GAAG,KAAKlD,cAAL,EAAZ;AACA,WAAO;AAACmD,MAAAA,aAAa,mBAAYD,KAAZ;AAAd,KAAP;AACH,GA9FW;;AAgGZ;;AAEA;AACA7C,EAAAA,OAnGY,mBAmGJ+C,MAnGI,EAmGIC,OAnGJ,EAmGaC,OAnGb,EAmGsB;AAC9B,QAAIC,UAAU,GAAGH,MAAM,CAACI,OAAP,CAAeH,OAAf,CAAjB;;AACA,QAAIE,UAAU,KAAK,CAAC,CAApB,EAAuB;AACnB;AACAA,MAAAA,UAAU,IAAIF,OAAO,CAACI,MAAtB;AACA,UAAIC,QAAQ,GAAGN,MAAM,CAACI,OAAP,CAAeF,OAAf,EAAwBC,UAAxB,CAAf;;AACA,UAAIG,QAAQ,KAAK,CAAC,CAAlB,EAAqB;AACjB,eAAON,MAAM,CAACO,KAAP,CAAaJ,UAAb,EAAyBG,QAAzB,CAAP;AACH,OAFD,MAEO;AACH,eAAON,MAAM,CAACO,KAAP,CAAaJ,UAAb,CAAP;AACH;AACJ;;AACD,WAAOK,SAAP;AACH;AAhHW,CAAhB;AAmHA,eAAe7D,OAAf","sourcesContent":["// TODO the clientId should not be committed to a public repo, so remove it and load it from a file?\nconst clientId = \"xxx\";\nconst spotifySearchAPI = 'https://api.spotify.com/v1/search';\nconst spotifyUserProfileAPI = 'https://api.spotify.com/v1/me';\n// @Reviewer: what's the preferred way to store urls with dynamic content?\nconst spotifyPlaylistAPI = 'https://api.spotify.com/v1/users/${userId}/playlists';\nconst spotifyPlaylistTracksAPI = 'https://api.spotify.com/v1/users/${userId}/playlists/${playlistId}/tracks';\nconst spotifyRedirectUrl = \"http://localhost:3000\";\n\nlet accessToken;\nlet expiresIn;\n\nconst Spotify = {\n\n    getAccessToken() {\n        // 1. case: already there?\n        if (accessToken) {\n            return accessToken;\n        }\n        // 2. case: already in URL?\n        let url = window.location.href;\n        accessToken = this.extract(url, \"access_token=\", \"&\");\n        if (accessToken) {\n            expiresIn = this.extract(url, \"expires_in=\", \"&\");\n            window.setTimeout(() => accessToken = '', expiresIn * 1000);\n            window.history.pushState('Access Token', null, '/');\n            console.log(\"access token successful retrieved.\");\n            return accessToken;\n        } else {\n            // 3. case: fetch from spotify\n            let state = 4321; // TODO generate state, save to app-state and validate\n            window.location.href = `https://accounts.spotify.com/authorize?client_id=${clientId}&response_type=token&scope=playlist-modify-private&redirect_uri=${spotifyRedirectUrl}&state=${state}`;\n        }\n    },\n\n    /* returns a promise */\n    search(term) {\n        return fetch(`${spotifySearchAPI}?type=track&q=${term}`,\n            {headers: this.buildAuthorizationHeader()})\n            .then(response => response.json())\n            .then(jsonResponse => {\n                if (jsonResponse.tracks) {\n                    return jsonResponse.tracks.items.map(function(track) {\n                        return {\n                            id: track.id,\n                            name: track.name,\n                            uri: track.uri,\n                            album: track.album.name,\n                            artist: track.artists[0].name\n                        }}\n                    )}\n                else {\n                    return [];\n                }\n            });\n    },\n\n    /* returns a promise */\n    savePlaylist(name, trackURIs) {\n      return fetch(`${spotifyUserProfileAPI}`,\n          {headers: this.buildAuthorizationHeader()})\n          .then(response => response.json())\n          .then(jsonResponse => {\n              let userId = jsonResponse.id;\n              return this.createPlaylistWithTracks(userId, name, trackURIs);\n          });\n    },\n\n    /* returns a promise */\n    createPlaylistWithTracks(userId, playlistName, playlistTracks) {\n        let jsonBody = JSON.stringify({name: playlistName, public: false});\n        let url = spotifyPlaylistAPI.replace(\"${userId}\", userId);\n        return fetch(url, { headers: this.buildAuthorizationHeader(),\n            method:'POST', body: jsonBody})\n            .then(response => this.handleResponse(response))\n            .then(jsonResponse => {\n                console.log(\"playlist successful created.\");\n                let playlistId = jsonResponse.id;\n                return this.saveTracksToPlaylist(userId, playlistId, playlistTracks);\n            });\n    },\n\n    /* returns a promise */\n    saveTracksToPlaylist(userId, playlistId, playlistTracks) {\n        let jsonBody = JSON.stringify(playlistTracks);\n        let url = spotifyPlaylistTracksAPI.replace(\"${userId}\", userId).replace(\"${playlistId}\", playlistId);\n        return fetch(url, { headers: this.buildAuthorizationHeader(),\n            method:'POST', body: jsonBody})\n            .then(response => this.handleResponse(response))\n            .then(jsonResponse => {\n                console.log(\"tracks successful stored\");\n                return jsonResponse.snapshot_id;\n            });\n    },\n\n    /* returns a promise */\n    handleResponse(response) {\n        if (response.ok) {\n            return response.json();\n        }\n        throw new Error('Request failed!');\n    },\n\n    buildAuthorizationHeader() {\n        let token = this.getAccessToken();\n        return {Authorization: `Bearer ${token}`};\n    },\n\n    /* extracts everything between the end of the keyword and the limiter from the string. if the keyword\n     * was not found, return undefined. */\n    // TODO write some tests for this\n    extract(string, keyword, limiter) {\n        let startIndex = string.indexOf(keyword);\n        if (startIndex !== -1) {\n            // add the length of the keyword to the start position to get the \"real\" start\n            startIndex += keyword.length;\n            let endIndex = string.indexOf(limiter, startIndex);\n            if (endIndex !== -1) {\n                return string.slice(startIndex, endIndex);\n            } else {\n                return string.slice(startIndex);\n            }\n        }\n        return undefined;\n    }\n};\n\nexport default Spotify;\n"]},"metadata":{},"sourceType":"module"}